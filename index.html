<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>GIS 라이트 (MST 통합 안정버전)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

<!-- Kakao Maps SDK -->
<script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=5f253bed8a8966a66fc9076b662663fd&libraries=services&autoload=false"></script>

<!-- 기존 스타일 -->
<link rel="stylesheet" href="https://hamancctv.github.io/2/style.css" />

<style>
html,body{height:100%;margin:0;}
#container{position:relative;height:100%;overflow:hidden;}
#mapWrapper{position:relative;width:100%;height:100%;z-index:1;}
#map{width:100%;height:100%;}
#rvWrapper{position:absolute;inset:0;display:none;z-index:0;}
#roadview{width:100%;height:100%;}
.view_roadview #rvWrapper{display:block;z-index:1;}
.view_roadview #mapWrapper{
  position:absolute;left:8px;bottom:8px;width:26%;height:26%;
  min-width:200px;min-height:150px;border:2px solid #ccc;border-radius:8px;background:#fff;z-index:2;
  box-shadow:0 8px 24px rgba(0,0,0,.2);
}
#close{
  position:absolute;top:8px;left:8px;padding:6px;background:#fff;border:1px solid #c8c8c8;border-radius:6px;
  cursor:pointer;z-index:3;box-shadow:0 1px #888;
}
#close .img{display:block;width:14px;height:14px;background:url(https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/rv_close.png) no-repeat;}
.toolbar{position:fixed;top:60px;left:10px;display:flex;flex-direction:column;gap:8px;z-index:10;}
.btn-satellite,#roadviewControl,#btnGroupMST{
  width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;
  border:1px solid #ccc;border-radius:8px;background:#fff;color:#555;
  cursor:pointer;transition:all .2s ease;box-sizing:border-box;
}
.btn-satellite:hover,#roadviewControl:hover,#btnGroupMST:hover{box-shadow:0 3px 12px rgba(0,0,0,.12);}
.btn-satellite.selected{border-color:#007aff;box-shadow:0 0 0 2px rgba(0,122,255,.15) inset;color:#007aff;}
#roadviewControl.active{border-color:#007aff;box-shadow:0 0 0 2px rgba(0,122,255,.15) inset;color:#007aff;}
#btnGroupMST.active{border-color:#db4040;box-shadow:0 0 0 2px rgba(219,64,64,.15) inset;color:#db4040;}
#btnGroupMST svg{width:26px;height:26px;display:block;}
#btnGroupMST svg path{stroke:currentColor;stroke-width:2.4;fill:none;}
#mapWrapper .rv-resizer{position:absolute;right:6px;top:6px;width:16px;height:16px;border:1px solid #bbb;border-radius:4px;background:#fff;cursor:nesw-resize;z-index:650;display:none;}
.view_roadview #mapWrapper .rv-resizer{display:block;}

/* === MapWalker (동동이) === */
.MapWalker{position:absolute;margin:-26px 0 0 -51px;cursor:grab;z-index:2147483647;}
.MapWalker.dragging{cursor:grabbing;}
.MapWalker .figure{
  position:absolute;width:25px;left:38px;top:-2px;height:39px;
  background:url(https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png) -298px -114px no-repeat;
  pointer-events:none;
}
.MapWalker .angleBase,.MapWalker .angleFront{
  position:absolute;left:0;top:0;width:102px;height:52px;
  background-image:url(https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png);
  background-repeat:no-repeat;
  filter: sepia(1) saturate(5.5) hue-rotate(8deg) brightness(1.12) contrast(0.98);
}
.MapWalker .angleBase{background-position:-834px -2px;opacity:.18;}
.MapWalker .angleFront{opacity:.92;}
/* (프레임별 클래스는 markers-handler와 동일 전제) */

/* 숫자/하이픈 이외 그룹 라벨 */
.mst-note {
  padding:2px 6px;background:rgba(255,255,255,.9);border:1px solid #db4040;border-radius:6px;
  font-size:12px;color:#db4040;white-space:nowrap;transform:translate(8px,-8px);
}
</style>
</head>
<body>
<div id="container">
  <div id="mapWrapper">
    <div id="map"></div>
    <div class="toolbar">
      <button id="btnSatellite" class="btn-satellite" title="위성뷰">
        <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="9"/></svg>
      </button>
      <button id="roadviewControl" title="로드뷰"></button>
      <button id="btnGroupMST" title="그룹 최소거리 연결">
        <svg viewBox="0 0 36 36"><path d="M8 26 L18 10 L28 26 M18 10 L18 26"/></svg>
      </button>
    </div>
    <div class="rv-resizer" aria-hidden="true"></div>
  </div>
  <div id="rvWrapper">
    <div id="roadview"></div>
    <div id="close" title="로드뷰 닫기"><span class="img"></span></div>
  </div>
</div>

<!-- 외부 스크립트 (원래 쓰던 것들 그대로) -->
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="https://hamancctv.github.io/2/sel_suggest.js"></script>
<script src="https://hamancctv.github.io/2/markers-handler.js"></script>
<script src="https://hamancctv.github.io/2/search-suggest.js"></script>
<script src="https://hamancctv.github.io/2/btnDistance.js"></script>
<!-- ⚠ drawGroupLinesMST.js는 제거 (중복/충돌 방지) -->

<script>
/* =========================================================
   0) 공통 유틸
========================================================= */
const $ = s => document.querySelector(s);
function flash(msg) {
  const el = document.createElement('div');
  el.textContent = msg;
  el.style.cssText =
    'position:fixed;left:50%;top:14px;transform:translateX(-50%);' +
    'background:rgba(0,0,0,.85);color:#fff;padding:8px 12px;border-radius:8px;' +
    'font-size:13px;z-index:9999;pointer-events:none';
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.opacity='0'; el.style.transition='opacity .25s'; }, 1100);
  setTimeout(()=> el.remove(), 1500);
}

/* =========================================================
   1) 로드뷰 패치 (Polyline 제외) — ON/OFF 가능
========================================================= */
const __rvOverlayRegistry = new Set();
let __rvOriginalSetMapMap = new WeakMap();
let __rvPatchesEnabled = false;

function enableOverlayPatch(){
  if (__rvPatchesEnabled) return;
  __rvPatchesEnabled = true;

  // ⚠ Polyline(=MST 선)은 제외해서 setMap 패치 충돌 방지
  const classes = [
    kakao.maps.CustomOverlay, kakao.maps.Marker,
    kakao.maps.InfoWindow, kakao.maps.Circle,
    kakao.maps.Rectangle, kakao.maps.Ellipse, kakao.maps.Polygon
  ].filter(Boolean);

  classes.forEach(C=>{
    if (!C || !C.prototype || C.prototype.__rvPatched) return;
    const origSetMap = C.prototype.setMap;
    if (typeof origSetMap !== 'function') return;

    __rvOriginalSetMapMap.set(C, origSetMap);
    C.prototype.setMap = function(m){
      const ret = origSetMap.call(this, m);
      if (m) __rvOverlayRegistry.add(this); else __rvOverlayRegistry.delete(this);
      return ret;
    };
    C.prototype.__rvPatched = true;
  });
}
function disableOverlayPatch(){
  if (!__rvPatchesEnabled) return;
  __rvPatchesEnabled = false;

  __rvOriginalSetMapMap.forEach((orig, C)=>{
    if (C && C.prototype && typeof orig === 'function') {
      C.prototype.setMap = orig;
      delete C.prototype.__rvPatched;
    }
  });
  __rvOriginalSetMapMap = new WeakMap();
  __rvOverlayRegistry.clear();
}

function setAllOverlaysForRV(disable){
  __rvOverlayRegistry.forEach(o=>{
    try{
      if (typeof o.getContent === 'function') {
        const el = o.getContent();
        if (el && el.style) el.style.pointerEvents = disable ? 'none' : 'auto';
      }
      if (typeof o.setZIndex === 'function') {
        if (o.__origZ === undefined && typeof o.getZIndex === 'function') {
          try { o.__origZ = o.getZIndex(); } catch(e){}
        }
        o.setZIndex(disable ? 1 : (o.__origZ ?? 100));
      }
    }catch(e){}
  });
}

/* =========================================================
   2) MST (그룹별 최소 신장 트리) — 외부 파일 없이 내장
========================================================= */
(function(){
  window.groupLines = [];
  window.mstNoteOverlays = [];
  let mapInstance = null;

  function getDistanceLL(lat1,lng1,lat2,lng2){
    const R=6371000, toRad=Math.PI/180;
    const φ1=lat1*toRad, φ2=lat2*toRad;
    const dφ=(lat2-lat1)*toRad, dλ=(lng2-lng1)*toRad;
    const a=Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
    return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  }

  function ensureMarkerCoords(markers){
    for(const m of markers){
      if (!m) continue;
      if (!isFinite(m.__lat) || !isFinite(m.__lng)) {
        try {
          const pos = m.getPosition();
          m.__lat = pos.getLat();
          m.__lng = pos.getLng();
        } catch(e){}
      }
    }
  }

  function buildGroups(markers){
    const groups={};
    for(const m of markers){
      if(!m) continue;
      if(!isFinite(m.__lat)||!isFinite(m.__lng)) continue;

      const g = (m.group ?? "").toString().trim();
      if(!g) continue;

      // 숫자/하이픈 이외 문자가 있으면: 선 연결 X, 라벨 표시
      if (/[^0-9\-]/.test(g)) {
        const label = document.createElement('div');
        label.className = 'mst-note';
        label.textContent = g;
        const ov = new kakao.maps.CustomOverlay({
          position: new kakao.maps.LatLng(m.__lat, m.__lng),
          content: label, yAnchor: 1
        });
        ov.setMap(mapInstance);
        window.mstNoteOverlays.push(ov);
        continue;
      }

      const key = g.replace(/[-\s]/g,"");
      if(!key) continue;
      if(!groups[key]) groups[key]=[];
      groups[key].push(m);
    }
    return groups;
  }

  function createMSTLinesForGroup(map,list){
    const unique=[...new Map(list.map(m=>[`${m.__lat},${m.__lng}`,m])).values()];
    if(unique.length<2) return 0;

    const connected=[unique[0]];
    let created=0;

    while(connected.length<unique.length){
      let minEdge=null;
      for(const cm of connected){
        for(const tm of unique){
          if(connected.includes(tm)) continue;
          const d=getDistanceLL(cm.__lat,cm.__lng,tm.__lat,tm.__lng);
          if(!minEdge||d<minEdge.dist) minEdge={from:cm,to:tm,dist:d};
        }
      }
      if(!minEdge) break;

      const p1=new kakao.maps.LatLng(minEdge.from.__lat,minEdge.from.__lng);
      const p2=new kakao.maps.LatLng(minEdge.to.__lat,minEdge.to.__lng);
      const line=new kakao.maps.Polyline({
        path:[p1,p2],
        strokeWeight:4,
        strokeColor:"#db4040",
        strokeOpacity:0.9,
        strokeStyle:"solid"
      });
      line.setMap(map); // Polyline은 패치 대상 아님
      window.groupLines.push(line);
      connected.push(minEdge.to);
      created++;
    }
    return created;
  }

  window.drawMSTAllGroups = function(){
    const map = mapInstance;
    if(!map) return;

    // 토글 OFF → 선/라벨 정리 후 종료
    if (window.groupLines.length > 0 || window.mstNoteOverlays.length > 0) {
      window.groupLines.forEach(l=>{ try{ l.setMap(null); }catch(e){} });
      window.groupLines = [];
      window.mstNoteOverlays.forEach(o=>{ try{ o.setMap(null); }catch(e){} });
      window.mstNoteOverlays = [];
      console.log("[MST] cleared");
      return;
    }

    const markers = window.markers || [];
    // 좌표 보정
    ensureMarkerCoords(markers);

    const groups = buildGroups(markers);
    let total=0;
    Object.values(groups).forEach(arr=>{
      if(Array.isArray(arr) && arr.length>=2){
        total += createMSTLinesForGroup(map, arr);
      }
    });
    console.log("[MST] total lines:", total);
  };

  window.setMapInstanceForMST = function(m){ mapInstance = m; };
})();

/* =========================================================
   3) 지도/로드뷰 초기화
========================================================= */
kakao.maps.load(function(){
  const center = new kakao.maps.LatLng(35.2725308711779,128.406307024695);
  const map = new kakao.maps.Map(document.getElementById('map'), { center, level:4 });
  map.setMaxLevel(9);

  // MST에 지도 인스턴스 전달
  setMapInstanceForMST(map);

  // 로드뷰
  let overlayOn=false, pickMode=false;
  let mapWalker=null;
  const rvClient = new kakao.maps.RoadviewClient();
  const rv = new kakao.maps.Roadview(document.getElementById('roadview'));
  const container = document.getElementById('container');

  // 동동이 생성
  function createMapWalker(pos){
    const content=document.createElement('div');
    const angleBase=document.createElement('div');
    const angleFront=document.createElement('div');
    const figure=document.createElement('div');
    content.className='MapWalker';
    angleBase.className='angleBase';
    angleFront.className='angleFront';
    figure.className='figure';
    content.appendChild(angleBase);
    content.appendChild(angleFront);
    content.appendChild(figure);
    const walker=new kakao.maps.CustomOverlay({position:pos,content,yAnchor:1,clickable:true});
    walker.setZIndex(2147483647);
    return walker;
  }

  function findNearestPanoId(position, cb, radii=[50,100,200,400,800,1600,3000]) {
    let i = 0;
    (function tryNext(){
      if (i >= radii.length) return cb(null);
      rvClient.getNearestPanoId(position, radii[i], function(panoId){
        if (panoId) return cb(panoId);
        i++; tryNext();
      });
    })();
  }

  function setRoadviewAt(position){
    findNearestPanoId(position, function(panoId){
      if (!panoId) { flash('근처에 로드뷰가 없어요'); return; }
      if (!container.classList.contains('view_roadview')) {
        container.classList.add('view_roadview');
        map.relayout();
      }
      map.setCenter(position);
      if (mapWalker) mapWalker.setPosition(position);
      rv.setPanoId(panoId, position);
    });
  }

  function toggleOverlay(active){
    const btn = document.getElementById('roadviewControl');
    if(active){
      overlayOn = true;
      btn.classList.add('active');
      enableOverlayPatch();
      setAllOverlaysForRV(true);
      map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);

      if(!mapWalker){
        mapWalker = createMapWalker(map.getCenter());
        mapWalker.setMap(map);
      }else{
        mapWalker.setPosition(map.getCenter());
        mapWalker.setMap(map);
      }
      setRoadviewAt(map.getCenter());
    }else{
      overlayOn = false;
      pickMode = false;
      btn.classList.remove('active');
      setAllOverlaysForRV(false);
      disableOverlayPatch();
      map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
      if(mapWalker){ mapWalker.setMap(null); mapWalker=null; }
      container.classList.remove('view_roadview');
      map.relayout();
    }
  }

  document.getElementById('roadviewControl').addEventListener('click', ()=> toggleOverlay(!overlayOn));
  document.getElementById('close').addEventListener('click', ()=> toggleOverlay(false));

  // 위성뷰 토글
  const btnSat = document.getElementById('btnSatellite');
  btnSat.addEventListener('click', ()=>{
    if(map.getMapTypeId() === kakao.maps.MapTypeId.ROADMAP){
      map.setMapTypeId(kakao.maps.MapTypeId.HYBRID);
      btnSat.classList.add('selected');
    }else{
      map.setMapTypeId(kakao.maps.MapTypeId.ROADMAP);
      btnSat.classList.remove('selected');
    }
  });

  // MST 버튼 (로드뷰 중에는 막아두자 — 안전)
  const btnMST = document.getElementById('btnGroupMST');
  btnMST.addEventListener('click', function(){
    if (overlayOn) {
      flash('로드뷰 모드에서는 MST를 사용할 수 없어요');
      this.classList.remove('active');
      return;
    }
    this.classList.toggle('active');
    window.drawMSTAllGroups();
  });

  /* ===== 외부 데이터 → 마커 생성 ===== */
  if (window.SEL_SUGGEST && typeof initMarkers === 'function') {
    const unique = new Map();
    const positionsLike = [];
    for (const it of window.SEL_SUGGEST) {
      const lat = parseFloat(it.lat), lng = parseFloat(it.lng);
      if (!isFinite(lat) || !isFinite(lng)) continue;
      const key = lat + ',' + lng;
      if (unique.has(key)) continue;
      unique.set(key, true);
      positionsLike.push({
        latlng: new kakao.maps.LatLng(lat, lng),
        content: it.name1 || it.name || '',
        searchName: it.name2 || it.name || '',
        group: it.group || null,
        __lat: lat,
        __lng: lng
      });
    }
    initMarkers(map, positionsLike);
  }

  // 제안창
  if (typeof initSuggestUI === 'function') {
    initSuggestUI({
      map,
      data: window.SEL_SUGGEST || [],
      parent: document.getElementById('mapWrapper'),
      getMarkers: () => window.markers,
      badges: ['line','enclosure','address','ip','group'],
      maxItems: 30,
      chooseOnEnter: true,
      openOnFocus: true
    });
  }

  /* ===== 미니맵(로드뷰시) 크기조절 ===== */
  (function setupMiniMapResizer(){
    const wrapper = document.getElementById('mapWrapper');
    const handle  = wrapper.querySelector('.rv-resizer');
    const MIN_W=200, MIN_H=150;
    const clamp=(v,min,max)=>Math.max(min,Math.min(v,max));
    const maxW=()=>Math.min(window.innerWidth*0.9, 900);
    const maxH=()=>Math.min(window.innerHeight*0.9, 700);

    function loadSize(){
      try{
        const saved = JSON.parse(localStorage.getItem('rvMiniSize')||'{}');
        if (saved && saved.w && saved.h) {
          wrapper.style.width  = saved.w + 'px';
          wrapper.style.height = saved.h + 'px';
          map.relayout();
        }
      }catch(e){}
    }
    function saveSize(w,h){
      try{ localStorage.setItem('rvMiniSize', JSON.stringify({w:Math.round(w), h:Math.round(h)})); }catch(e){}
    }

    let startX,startY,startW,startH,curW,curH,active=false,rafId=null;
    function applySize(){
      rafId=null;
      if(curW&&curH){ wrapper.style.width=curW+'px'; wrapper.style.height=curH+'px'; map.relayout(); }
    }
    function onDown(ev){
      ev.preventDefault(); ev.stopPropagation();
      const t = ev.touches ? ev.touches[0] : ev;
      startX=t.clientX; startY=t.clientY;
      const r=wrapper.getBoundingClientRect(); startW=r.width; startH=r.height;
      active=true;
      document.addEventListener('mousemove', onMove, {passive:false});
      document.addEventListener('mouseup',   onUp,   {passive:false});
      document.addEventListener('touchmove', onMove, {passive:false});
      document.addEventListener('touchend',  onUp,   {passive:false});
    }
    function onMove(ev){
      if(!active) return;
      ev.preventDefault();
      const t = ev.touches ? ev.touches[0] : ev;
      const dx=t.clientX-startX, dy=t.clientY-startY;
      curW=clamp(startW+dx, MIN_W, maxW());
      curH=clamp(startH-dy, MIN_H, maxH());
      if(!rafId) rafId=requestAnimationFrame(applySize);
    }
    function onUp(ev){
      if(!active) return;
      ev.preventDefault();
      active=false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup',   onUp);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend',  onUp);
      if(curW&&curH) saveSize(curW,curH);
    }
    handle.addEventListener('mousedown', onDown, {passive:false});
    handle.addEventListener('touchstart', onDown, {passive:false});

    const mo=new MutationObserver(()=>{
      const rvOn = container.classList.contains('view_roadview');
      if(rvOn) loadSize();
      else { wrapper.style.width='100%'; wrapper.style.height='100%'; map.relayout(); }
    });
    mo.observe(container, {attributes:true, attributeFilter:['class']});
    if (container.classList.contains('view_roadview')) loadSize();
  })();
});
</script>
</body>
</html>
