<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>GIS 모바일</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="icon" href="https://hamancctv.github.io/2/favicon.ico" sizes="32x32"/>
  <link rel="stylesheet" href="https://hamancctv.github.io/2/style.css">
  <style>
    /* 검색 UI가 지도 위에 자연스럽게 놓이도록 약간의 여유 */
    #mapWrapper { position: relative; }
  </style>
</head>
<body>
  <div id="alert-overlay"><div id="alert-message"></div></div>
  <button id="btnDistance">거리</button>

  <div id="container">
    <div id="rvWrapper">
      <div id="roadview" style="width:100%;height:100%;"></div>
      <div id="close" title="로드뷰닫기" onclick="closeRoadview()"><span class="img"></span></div>
    </div>
    <div id="mapWrapper">
      <div id="map" style="width:100%;height:100%"></div>
      <div id="roadviewControl" onclick="setRoadviewRoad()"></div>
      </div>
  </div>

  <div class="toolbar-right">
    <input type="text" id="gpsyx" class="input-common" inputmode="none"
           value="35.2725308711779, 128.406307024695"/>
    <button id="btn_input_copy" class="btn-common">복사</button>
  </div>

  <div class="custom_typecontrol2_m radius_border">
    <span id="toggle_group" class="btn btn-common">회선</span>
    <span id="btnCurrentMe" class="btn btn-common" onclick="toggleMyLocation()">위치</span>
    <span id="btnTrackMe" class="btn btn-common" onclick="toggleTracking()">추적</span>
  </div>

  <script src="//dapi.kakao.com/v2/maps/sdk.js?appkey=5f253bed8a8966a66fc9076b662663fd&libraries=services,clusterer,drawing&autoload=false"></script>
  <script src="https://code.jquery.com/jquery-3.6.1.js" integrity="sha256-3zlB5s2uwoUzrXK3BT7AX3FyvojsraNFxCc2vC/7pNI=" crossorigin="anonymous"></script>

  <script src="https://hamancctv.github.io/2/sel_suggest.js"></script>

  <script src="https://hamancctv.github.io/2/drawGroupLinesMST.js?v=20250929a"></script>
  <script src="https://hamancctv.github.io/2/btnDistance.js?v=20250929a"></script>
  
  <script>
      // markers-handler.js (v2025-09-29d-FIXED)
      (function () {
          console.log("[markers-handler] loaded v2025-09-29d-FIXED");

          // === 오버레이 기본 스타일 ===
          const style = document.createElement("style");
          style.textContent = `
            .overlay-hover{
              padding:2px 6px;
              background:rgba(255,255,255,0.80);
              border:1px solid #ccc;
              border-radius:5px;
              font-size:14px;
              white-space:nowrap;
              user-select:none;
              transition:transform .15s ease, border .15s ease, background .15s ease;
              will-change:transform, border;
              transform:translateZ(0);
              backface-visibility:hidden;
            }
          `;
          document.head.appendChild(style);

          // === Z 레이어 ===
          const Z = { BASE:100, FRONT:100000 }; // 기본/전면

          // === 전역 상태 ===
          let selectedMarker = null;       // 파란 테두리 쌍
          let selectedOverlayEl = null;
          let selectedOverlayObj = null;

          let frontMarker = null;          // 현재 전면 쌍(호버/클릭)
          let frontOverlay = null;
          let frontReason = null;          // 'hover' | 'clickMarker' | 'clickOverlay'

          let normalImage, hoverImage, jumpImage;
          let clickStartTime = 0;

          // === 위치/높이 ===
          const normalH = 42, hoverH = 50.4, gap = 2;
          const baseY  = -(normalH + gap);  // -44
          const hoverY = -(hoverH  + gap);  // -52.4
          const jumpY  = -(70      + gap);  // -72

          // === z-index 유틸 ===
          function setDefaultZ(marker, overlay){ // 기본: 마커 > 오버레이
            if (marker) marker.setZIndex(Z.BASE + 1);
            if (overlay) overlay.setZIndex(Z.BASE);
          }
          function setFrontZ(marker, overlay){   // 전면: 오버레이 > 마커
            if (marker) marker.setZIndex(Z.FRONT);
            if (overlay) overlay.setZIndex(Z.FRONT + 1);
          }
          function bringToFront(map, marker, overlay, reason){
            if (!marker || !overlay) return;
            if (frontMarker && frontOverlay && (frontMarker !== marker || frontOverlay !== overlay)) {
              setDefaultZ(frontMarker, frontOverlay);
              if (map.getLevel() > 3 && frontMarker !== selectedMarker) frontOverlay.setMap(null);
            }
            overlay.setMap(map);         // 전면은 항상 표시
            setFrontZ(marker, overlay);
            frontMarker = marker; frontOverlay = overlay; frontReason = reason;
          }

          // === 순수 한글만 추출(숫자/기호/영문 제거, 공백 정리) ===
          function extractPureHangul(str){
            // HTML 가능성도 있어 대비
            const tmp = document.createElement("div");
            tmp.innerHTML = String(str ?? "");
            const plain = tmp.textContent || tmp.innerText || "";
            const m = plain.match(/[가-힣\s]+/g);
            return m ? m.join(" ").replace(/\s+/g, " ").trim() : "";
          }

          // === 검색창/제안 UI 주입 (수정됨: .gx-input을 찾습니다) ===
          function pushToSearchUI(query) {
            if (!query) { console.warn("[markers-handler] empty query; skip"); return; }
            
            // ⚠️ 수정된 부분: 동적으로 삽입된 input을 찾기 위해 querySelector 사용
            const kw = document.querySelector('.gx-suggest-search .gx-input');
            
            if (!kw) { 
                console.warn("[markers-handler] .gx-suggest-search .gx-input not found"); 
                return; 
            }

            // 지연 주입으로 다른 핸들러와 충돌 최소화
            setTimeout(() => {
              try {
                kw.value = query;
                console.log("[markers-handler] injected query:", query);

                // input 이벤트를 발생시켜 search-suggest.js의 리스너가 반응하도록 유도
                kw.dispatchEvent(new Event('input',  { bubbles: true }));
                kw.dispatchEvent(new Event('change', { bubbles: true }));
              } catch(e){
                console.error("[markers-handler] pushToSearchUI error:", e);
              }
            }, 0);
          }

          // === 지도 클릭: 파란 테두리만 해제(전면 상태/레이어 유지) ===
          function bindMapClickToClearSelection(map){
            kakao.maps.event.addListener(map, "click", function(){
              if (selectedOverlayEl) selectedOverlayEl.style.border = "1px solid #ccc";
              selectedMarker = null; selectedOverlayEl = null; selectedOverlayObj = null;
            });
          }

          // === 마커 초기화 ===
          window.initMarkers = function (map, positions) {
            bindMapClickToClearSelection(map);

            normalImage = new kakao.maps.MarkerImage(
              "https://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
              new kakao.maps.Size(30,42), { offset:new kakao.maps.Point(15,42) }
            );
            hoverImage = new kakao.maps.MarkerImage(
              "https://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
              new kakao.maps.Size(36,50.4), { offset:new kakao.maps.Point(18,50.4) }
            );
            jumpImage = new kakao.maps.MarkerImage(
              "https://t1.daumcdn.net/localimg/localimages/07/2018/pc/img/marker_spot.png",
              new kakao.maps.Size(30,42), { offset:new kakao.maps.Point(15,70) }
            );

            const markers = []; const overlays = [];
            const batchSize = 50; let idx = 0;

            function createBatch(){
              const end = Math.min(positions.length, idx + batchSize);
              for (let i=idx;i<end;i++){
                (function(i){
                  const pos = positions[i];

                  // --- Marker ---
                  const marker = new kakao.maps.Marker({
                    map, position: pos.latlng, image: normalImage, clickable:true, zIndex: Z.BASE+1
                  });
                  marker.group = pos.group ? String(pos.group) : (pos.line ? String(pos.line) : null);

                  // --- Overlay ---
                  const el = document.createElement("div");
                  el.className = "overlay-hover";
                  el.style.transform = `translateY(${baseY}px)`;
                  el.textContent = pos.content;

                  const overlay = new kakao.maps.CustomOverlay({
                    position: pos.latlng, content: el, yAnchor:1, map:null
                  });
                  overlay.setZIndex(Z.BASE);

                  marker.__overlay = overlay; overlay.__marker = marker;
                  marker.__lat = pos.latlng.getLat(); marker.__lng = pos.latlng.getLng();

                  // === Hover in ===
                  function onOver(){
                    marker.setImage(hoverImage);
                    bringToFront(map, marker, overlay, 'hover');
                    el.style.transform = (marker===selectedMarker) ? `translateY(${hoverY-2}px)` : `translateY(${hoverY}px)`;
                  }
                  // === Hover out ===
                  function onOut(){
                    marker.setImage(normalImage);
                    const wasHoverFront = (frontMarker===marker && frontOverlay===overlay && frontReason==='hover');
                    if (wasHoverFront){
                      el.style.transform=`translateY(${baseY}px)`;
                      if (selectedMarker && selectedOverlayObj){
                        bringToFront(map, selectedMarker, selectedOverlayObj, 'clickMarker');
                        if (selectedOverlayEl){
                          selectedOverlayEl.style.border="2px solid blue";
                          selectedOverlayEl.style.transform=`translateY(${baseY-2}px)`;
                        }
                      }
                      return;
                    }
                    if (marker===selectedMarker){
                      el.style.transform=`translateY(${baseY-2}px)`; el.style.border="2px solid blue";
                      bringToFront(map, selectedMarker, selectedOverlayObj||overlay, 'clickMarker');
                    } else {
                      el.style.transform=`translateY(${baseY}px)`;
                      if (map.getLevel()>3 && overlay!==frontOverlay && overlay!==selectedOverlayObj) overlay.setMap(null);
                      if (!(frontMarker===marker && frontOverlay===overlay)) setDefaultZ(marker, overlay);
                      if (frontMarker && frontOverlay) setFrontZ(frontMarker, frontOverlay);
                    }
                  }

                  kakao.maps.event.addListener(marker, "mouseover", onOver);
                  kakao.maps.event.addListener(marker, "mouseout",  onOut);
                  el.addEventListener("mouseover", onOver);
                  el.addEventListener("mouseout",  onOut);

                  // === Marker mousedown: 점프/전면/선택 ===
                  kakao.maps.event.addListener(marker, "mousedown", function(){
                    marker.setImage(jumpImage); clickStartTime=Date.now();
                    if (selectedOverlayEl) selectedOverlayEl.style.border="1px solid #ccc";
                    selectedMarker=marker; selectedOverlayEl=el; selectedOverlayObj=overlay;
                    bringToFront(map, marker, overlay, 'clickMarker');
                    el.style.border="2px solid blue"; el.style.transform=`translateY(${jumpY-2}px)`;
                  });

                  // === Marker mouseup: 복귀 + 좌표/검색 주입 ===
                  kakao.maps.event.addListener(marker, "mouseup", function(){
                    const elapsed=Date.now()-clickStartTime; const delay=Math.max(0,100-elapsed);
                    setTimeout(function(){
                      marker.setImage(normalImage);
                      el.style.border="2px solid blue";
                      el.style.transition="transform .2s ease, border .2s ease";
                      el.style.transform=`translateY(${baseY-2}px)`;
                      bringToFront(map, marker, overlay, 'clickMarker');

                      // ① 좌표 input 업데이트
                      const g = document.getElementById("gpsyx");
                      if (g) g.value = `${marker.__lat}, ${marker.__lng}`;

                      // ② 마커 표시명에서 "순수 한글"만 추출 → 실패 시 3중 백업 후 주입
                      let pure = extractPureHangul(pos.content);
                      if (!pure) pure = extractPureHangul(el.textContent || "");
                      if (!pure) {
                        const t = document.createElement("div");
                        t.innerHTML = String(pos.content ?? "");
                        pure = extractPureHangul(t.textContent || "");
                      }
                      console.log("[markers-handler] pureHangul:", pure);
                      pushToSearchUI(pure); // 💥 수정된 pushToSearchUI 함수 호출

                      setTimeout(()=>{ el.style.transition="transform .15s ease, border .15s ease"; }, 200);
                    }, delay);
                  });

                  // === Overlay click: 전면만, 테두리/입력/검색 갱신 없음 ===
                  el.addEventListener("click", function(){
                    bringToFront(map, marker, overlay, 'clickOverlay');
                    el.style.border="1px solid #ccc";
                    el.style.transform=`translateY(${baseY}px)`;
                  });

                  markers.push(marker); overlays.push(overlay);
                })(i);
              }
              idx=end;
              if (idx<positions.length) setTimeout(createBatch, 0);
              else window.markers=markers;
            }
            createBatch();

            // === idle: 전면/선택은 항상 표시, 나머지는 level<=3에서만 ===
            kakao.maps.event.addListener(map, "idle", function(){
              const level = map.getLevel();
              const list = window.markers || [];
              for (const m of list){
                const o = m.__overlay; if (!o) continue;
                if ((frontOverlay && o===frontOverlay) || (selectedOverlayObj && o===selectedOverlayObj)) {
                  o.setMap(map);
                } else {
                  level<=3 ? o.setMap(map) : o.setMap(null);
                }
                if (frontOverlay && o===frontOverlay) setFrontZ(m,o); else setDefaultZ(m,o);
              }
              if (frontMarker && frontOverlay) setFrontZ(frontMarker, frontOverlay);
            });
          };
      })();
  </script>

  <script>
  // search-suggest.js (분리본을 여기 인라인으로 넣었어)
  (function () {
    const CSS = `
    .gx-suggest-search{
      position:absolute; top:8px; left:50%; transform:translateX(-50%);
      display:flex; gap:8px; align-items:center;
      width:min(520px,90vw); z-index:600;
    }
    .gx-suggest-search input{
      flex:1; height:40px; padding:0 12px; border:1px solid #ccc; border-radius:10px;
      background:#fff; font-size:14px; outline:none;
    }
    .gx-suggest-search button{ display:none; }
    .gx-suggest-box{
      position:absolute; top:48px; left:50%; transform:translateX(-50%) translateY(-6px);
      width:min(520px,90vw);
      max-height:40vh; overflow-y:auto;
      border:1px solid #ccc; border-radius:10px;
      background:rgba(255,255,255,0.96);
      box-shadow:0 8px 20px rgba(0,0,0,.15);
      z-index:610;
      opacity:0; pointer-events:none; transition:opacity .18s ease, transform .18s ease;
      display:block;
    }
    .gx-suggest-box.open{ opacity:1; transform:translateX(-50%) translateY(0); pointer-events:auto; }
    .gx-suggest-item{ padding:10px 12px; cursor:pointer; display:flex; align-items:center; gap:8px; }
    .gx-suggest-item:hover, .gx-suggest-item.active{ background:#eef3ff; }
    .gx-suggest-title{ display:inline-block; max-width:60%; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; font-weight:600; }
    .gx-badge{ font-size:12px; color:#555; background:#f2f4f8; padding:2px 6px; border-radius:6px; }
    .gx-suggest-empty{ color:#777; padding:12px; }
    `;
    const styleEl = document.createElement('style'); styleEl.textContent = CSS; document.head.appendChild(styleEl);

    const CHO = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
    const CHO_SET = new Set(CHO);
    const normalize = s => (s||"").toUpperCase().replace(/\s+/g,"");
    function buildKey(str){
      let out=""; for (const ch of (str||"")){
        const c = ch.charCodeAt(0);
        if (c>=0xAC00 && c<=0xD7A3) out += CHO[Math.floor((c-0xAC00)/588)];
        else if (CHO_SET.has(ch)) out += ch;
        else if (c>=48&&c<=57) out += ch;
        else if (c>=65&&c<=90) out += ch;
        else if (c>=97&&c<=122) out += ch.toUpperCase();
      }
      return out;
    }
    const esc = s => (s||"").replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

    function initSuggestUI(opts){
      const {
        map,
        data = window.SEL_SUGGEST || [],
        parent = document.getElementById('mapWrapper') || document.body,
        getMarkers = () => window.markers || [],
        badges = ['line','encloser','ip'],
        maxItems = 30,
        chooseOnEnter = true,
        openOnFocus = true
      } = opts || {};
      if (!map) { console.error('initSuggestUI: map 필요'); }

      const wrap = document.createElement('div');
      wrap.className = 'gx-suggest-search';
      // ⚠️ 중요: input에 id="keyword"를 추가하지 않습니다. markers-handler를 수정해서 .gx-input을 찾도록 했습니다.
      wrap.innerHTML = `
        <input type="search" class="gx-input" placeholder="예) ㅎㅇㄱㅂㄱㅅ, ㄷ032, 시설명…" autocomplete="off" /> 
        <button type="button" class="gx-btn">검색</button>
      `;
      const box = document.createElement('div'); box.className = 'gx-suggest-box';
      parent.appendChild(wrap); parent.appendChild(box);

      const kw = wrap.querySelector('.gx-input');
      const RAW = (data||[]).filter(it => it && (it.name||it.addr||it.ip)).map((it,idx)=>({
        id: it.id || `s_${idx}`,
        name: it.name || "",
        line: it.line || "",
        encloser: it.encloser || "",
        addr: it.addr || "",
        lat: it.lat, lng: it.lng,
        ip: it.ip || ""
      }));
      RAW.forEach(it=>{
        it.key = buildKey([it.name, it.line, it.encloser, it.ip].filter(Boolean).join(" "));
        it.nameLen = (it.name||"").length;
      });
      const IDMAP = Object.fromEntries(RAW.map(it => [it.id, it]));

      function match(q){
        const k = buildKey(q); if (!k) return [];
        const res=[];
        for (const it of RAW){
          if (it.key.indexOf(k)!==-1) res.push(it);
          if (res.length>=2000) break;
        }
        res.sort((a,b)=>{
          const ai=a.key.indexOf(k), bi=b.key.indexOf(k);
          if (ai!==bi) return ai-bi;
          if (a.nameLen!==b.nameLen) return a.nameLen-b.nameLen;
          return a.id.localeCompare(b.id);
        });
        return res.slice(0, maxItems);
      }
      function render(items){
        if (!items.length){ box.innerHTML = `<div class="gx-suggest-empty">검색 결과 없음</div>`; return; }
        box.innerHTML = items.map(it=>{
          const title = esc(it.name);
          const badgeHtml = badges.map(b=>{
            const v = it[b]; return v ? `<span class="gx-badge">${esc(String(v))}</span>` : '';
          }).join('');
          return `<div class="gx-suggest-item" data-id="${it.id}">
            <span class="gx-suggest-title">${title}</span>${badgeHtml}
          </div>`;
        }).join('');
      }
      const openBox = ()=> box.classList.add('open');
      const closeBox= ()=> { box.classList.remove('open'); setActive(-1); };

      let active=-1, rafId=null;
      function setActive(i){
        const items = box.querySelectorAll('.gx-suggest-item');
        items.forEach((el,idx)=> el.classList.toggle('active', idx===i));
        active=i;
        if (i>=0 && items[i]) items[i].scrollIntoView({block:'nearest'});
      }
      function schedule(q){
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(()=>{
          rafId=null;
          const items = match(q);
          if (items.length){ render(items); openBox(); setActive(-1); }
          else closeBox();
        });
      }
      function applySelection(item){
        if (!item) return;
        kw.value = item.name;
        const markers = getMarkers()||[];
        const found = markers.find(m=>{
          const p=m.getPosition?.(); if (!p) return false;
          return Math.abs(p.getLat()-item.lat)<1e-9 && Math.abs(p.getLng()-item.lng)<1e-9;
        });
        if (found && window.kakao && window.kakao.maps){
          // 마커를 찾으면 마커의 mousedown/mouseup 이벤트를 직접 트리거하여 마커 클릭과 동일한 효과를 냅니다.
          kakao.maps.event.trigger(found,"mousedown");
          setTimeout(()=>kakao.maps.event.trigger(found,"mouseup"),0);
          map.panTo(found.getPosition());
        } else if (Number.isFinite(item.lat)&&Number.isFinite(item.lng)){
          map.panTo(new kakao.maps.LatLng(item.lat,item.lng));
        }
        closeBox();
      }

      kw.addEventListener('compositionupdate', ()=>{ const v=kw.value.trim(); if(!v){closeBox();return;} schedule(v); });
      kw.addEventListener('input', ()=>{ const v=kw.value.trim(); if(!v){closeBox();return;} schedule(v); });
      kw.addEventListener('keydown', e=>{
        const visible = box.classList.contains('open');
        if (visible){
          const items = box.querySelectorAll('.gx-suggest-item');
          if (e.key==='ArrowDown'){ e.preventDefault(); setActive(active<items.length-1?active+1:0); }
          else if (e.key==='ArrowUp'){ e.preventDefault(); setActive(active>0?active-1:items.length-1); }
          else if (e.key==='Enter'){ e.preventDefault(); const list=match(kw.value); if(list.length){ applySelection(active>=0? list[active] : list[0]); } else closeBox(); }
          else if (e.key==='Escape'){ closeBox(); }
        } else if (e.key==='Enter'){
          e.preventDefault(); const list=match(kw.value); if(list.length) applySelection(list[0]);
        }
      });

      box.addEventListener('mousedown', e=>{
        const el = e.target.closest('.gx-suggest-item'); if(!el) return;
        applySelection(IDMAP[el.dataset.id]); e.preventDefault();
      });
      if (openOnFocus){
        kw.addEventListener('focus', ()=>{ const v=kw.value.trim(); if(v) schedule(v); });
      }
      document.addEventListener('click', (e)=>{
        const within = e.target.closest('.gx-suggest-search') || e.target.closest('.gx-suggest-box');
        if (!within) closeBox();
      });

      return {
        setData(newData){
          RAW.length=0;
          (newData||[]).forEach((it,idx)=>{
            const row={
              id: it.id||`s_${idx}`, name: it.name||"", line: it.line||"",
              encloser: it.encloser||"", addr: it.addr||"", lat: it.lat, lng: it.lng, ip: it.ip||""
            };
            row.key = buildKey([row.name,row.line,row.encloser,row.ip].filter(Boolean).join(" "));
            row.nameLen = (row.name||"").length;
            RAW.push(row);
          });
          Object.keys(IDMAP).forEach(k=>delete IDMAP[k]);
          RAW.forEach(it=>IDMAP[it.id]=it);
        }
      };
    }

    window.initSuggestUI = initSuggestUI;
  })();
  </script>

  <script>
  // ===== 앱 초기화: Kakao SDK 로드 후 시작 =====
  kakao.maps.load(function () {
    // 맵 생성
    const mapCenter = new kakao.maps.LatLng(35.2725308711779, 128.406307024695);
    const map = new kakao.maps.Map(document.getElementById('map'), { center: mapCenter, level: 4 });
    map.setMaxLevel(9);
    window.map = map;

    // 로드뷰 설정
    var rv = new kakao.maps.Roadview(document.getElementById('roadview'));
    var rvClient = new kakao.maps.RoadviewClient();
    var overlayOn = false;
    var marker = new kakao.maps.Marker({
      image: new kakao.maps.MarkerImage(
        'https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png',
        new kakao.maps.Size(26,46),
        { spriteSize:new kakao.maps.Size(1666,168), spriteOrigin:new kakao.maps.Point(705,114), offset:new kakao.maps.Point(13,46) }
      ),
      position: mapCenter, draggable: true
    });

    kakao.maps.event.addListener(rv,'position_changed',function(){
      const rvPos = rv.getPosition(); map.setCenter(rvPos); if(overlayOn) marker.setPosition(rvPos);
    });
    kakao.maps.event.addListener(marker,'dragend',()=>toggleRoadview(marker.getPosition()));
    kakao.maps.event.addListener(map,'click',function(mouseEvent){
      if(!overlayOn) return;
      const position = mouseEvent.latLng; marker.setPosition(position); toggleRoadview(position);
    });
    function toggleRoadview(position){
      rvClient.getNearestPanoId(position, 50, function(panoId) {
        if (panoId === null) toggleMapWrapper(true, position);
        else { toggleMapWrapper(false, position); rv.setPanoId(panoId, position); }
      });
    }
    function toggleMapWrapper(active, position) {
      const container = document.getElementById('container');
      if (active) { container.className=''; map.relayout(); map.setCenter(position); }
      else {
        if (container.className.indexOf('view_roadview') === -1) {
          container.className='view_roadview'; map.relayout(); map.setCenter(position);
        }
      }
    }
    function toggleOverlay(active) {
      if (active) {
        overlayOn = true; map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        marker.setMap(map); if (window.marker1) window.marker1.setMap(null);
        marker.setPosition(map.getCenter()); toggleRoadview(map.getCenter());
      } else {
        overlayOn = false; map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
        marker.setMap(null); if (window.marker1) window.marker1.setMap(map);
      }
    }
    window.setRoadviewRoad = function(){
      var c = document.getElementById('roadviewControl');
      if (c.className.indexOf('active') === -1) { c.className='active'; toggleOverlay(true); }
      else { c.className=''; toggleOverlay(false); }
    };
    window.closeRoadview = function(){ toggleMapWrapper(true, marker.getPosition()); };

    // 지도 타입 컨트롤
    var mapTypeControl = new kakao.maps.MapTypeControl();
    map.addControl(mapTypeControl, kakao.maps.ControlPosition.TOPLEFT);

    // 내 위치 / 추적 (네 기존 로직 그대로)
    var myLocationOn=false, trackOn=false, myLocationMarker=null, trackMarker=null, trackInterval=null, watchId=null;
    var markerImage = new kakao.maps.MarkerImage('https://hamancctv.github.io/2/icon-target.png', new kakao.maps.Size(32,32), { offset: new kakao.maps.Point(16,16) });
    window.toggleMyLocation = function(){
      if(trackOn) stopTracking();
      if(!myLocationOn){
        myLocationOn=true; document.getElementById('btnCurrentMe').classList.add('selected_btn');
        navigator.geolocation.getCurrentPosition(function(pos){ showMyLocation(pos.coords.latitude,pos.coords.longitude); }, geoError, {enableHighAccuracy:true});
      } else {
        myLocationOn=false; document.getElementById('btnCurrentMe').classList.remove('selected_btn');
        if(myLocationMarker){ myLocationMarker.setMap(null); myLocationMarker=null; }
      }
    };
    function showMyLocation(lat,lng){
      var latLng=new kakao.maps.LatLng(lat,lng);
      if(!myLocationMarker){
        myLocationMarker=new kakao.maps.Marker({ position:latLng, map:map, image:markerImage });
        kakao.maps.event.addListener(myLocationMarker,'click',function(){ map.panTo(myLocationMarker.getPosition()); map.setLevel(4); });
      } else { myLocationMarker.setPosition(latLng); myLocationMarker.setMap(map); }
      map.panTo(latLng); map.setLevel(5);
    }
    window.toggleTracking = function(){
      if(myLocationOn) toggleMyLocation();
      if(!trackOn) startTracking(); else stopTracking();
    };
    function startTracking(){
      trackOn=true; document.getElementById('btnTrackMe').classList.add('selected_btn');
      watchId = navigator.geolocation.watchPosition(function(pos){
        var latLng=new kakao.maps.LatLng(pos.coords.latitude,pos.coords.longitude);
        if(!trackMarker){ trackMarker=new kakao.maps.Marker({position:latLng,map:map,image:markerImage}); }
        else { trackMarker.setPosition(latLng); trackMarker.setMap(map); }
        map.panTo(latLng);
      }, geoError, {enableHighAccuracy:true});
      trackInterval=setInterval(()=>{ if(trackMarker) trackMarker.setVisible(!trackMarker.getVisible()); }, 500);
    }
    function stopTracking(){
      trackOn=false; document.getElementById('btnTrackMe').classList.remove('selected_btn');
      if(watchId){ navigator.geolocation.clearWatch(watchId); watchId=null; }
      if(trackInterval){ clearInterval(trackInterval); trackInterval=null; }
      if(trackMarker){ trackMarker.setVisible(true); trackMarker.setMap(null); trackMarker=null; }
    }
    function geoError(err){ console.error('GPS error:', err); }

    // 지도 중심 좌표 input 갱신
    kakao.maps.event.addListener(map,'center_changed',function(){
      var latlng = map.getCenter(); $('#gpsyx').val(latlng.getLat()+', '+latlng.getLng());
    });

    // 복사 버튼
    document.getElementById("btn_input_copy").onclick = function(){
      const g = document.getElementById("gpsyx"); g.select(); document.execCommand('copy');
    };

    // ===== positions 생성: sel_suggest → positions (group= line) =====
  const positions = (window.SEL_SUGGEST || [])
   .map(it => {
     const lat = parseFloat(it.lat);
     const lng = parseFloat(it.lng);
     if (!isFinite(lat) || !isFinite(lng)) return null; // 좌표가 없거나 NaN이면 스킵
     return {
       latlng: new kakao.maps.LatLng(lat, lng),
       content: it.name,
       group: it.line || null
     };
   })
   .filter(Boolean);

  // 디버깅용: 몇 개 찍혔는지 확인
  console.log('SEL_SUGGEST:', (window.SEL_SUGGEST||[]).length, ' → positions:', positions.length);

    // 중복 좌표 제거(기존 로직 유지)
    const unique={}, filtered=[];
    for (let i=0;i<positions.length;i++){
      const lat=positions[i].latlng.getLat(), lng=positions[i].latlng.getLng();
      const key = lat+","+lng;
      if (!unique[key]) { unique[key]=true; filtered.push(positions[i]); }
    }

    // 마커 생성
    if (window.initMarkers) initMarkers(map, filtered); // markers-handler.js 가 window.markers 설정

    // 회선 토글
    const toggleGroupBtn = document.getElementById("toggle_group");
    if (window.drawGroupLinesMST) { // drawGroupLinesMST.js가 로드되었다고 가정
      toggleGroupBtn.addEventListener("click", function () {
        drawGroupLinesMST(map); // drawGroupLinesMST 함수는 map 인수를 받는지 확인 필요
        toggleGroupBtn.classList.toggle("selected_btn");
      });
    }

    // ===== 검색창 + 제안 붙이기 =====
    if (window.initSuggestUI) {
        const suggestUI = initSuggestUI({
          map,
          data: window.SEL_SUGGEST,
          parent: document.getElementById('mapWrapper'),
          getMarkers: () => window.markers,
          badges: ['line','encloser','ip'], // 표시 배지
          maxItems: 30,
          chooseOnEnter: true,
          openOnFocus: true
        });
    }

  }); // kakao.maps.load
  </script>
</body>
</html>
